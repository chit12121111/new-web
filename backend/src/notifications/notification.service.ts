'use strict';

import { Injectable, Logger } from '@nestjs/common';
import * as nodemailer from 'nodemailer';
import axios from 'axios';

interface ImageNotificationPayload {
  userEmail: string;
  prompt: string;
  model: string;
  provider: string;
  imageUrl: string;
}

@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);
  private readonly emailTransporter?: nodemailer.Transporter;
  private readonly emailFrom?: string;
  private readonly emailTo?: string;
  private readonly discordWebhookUrl?: string;
  private readonly notifyOnImageGeneration: boolean;

  constructor() {
    this.notifyOnImageGeneration =
      (process.env.NOTIFY_ON_IMAGE_GENERATION || 'false').toLowerCase() === 'true';

    const emailHost = process.env.EMAIL_HOST;
    const emailPort = process.env.EMAIL_PORT ? parseInt(process.env.EMAIL_PORT, 10) : 465;
    const emailUser = process.env.EMAIL_USER;
    const emailPass = process.env.EMAIL_PASS;
    this.emailFrom = process.env.EMAIL_FROM || emailUser;
    this.emailTo = process.env.ALERT_EMAIL_TO;

    if (emailHost && emailUser && emailPass) {
      this.emailTransporter = nodemailer.createTransport({
        host: emailHost,
        port: emailPort,
        secure: emailPort === 465,
        auth: {
          user: emailUser,
          pass: emailPass,
        },
      });
      this.logger.log('üìß Email notifications enabled');
    } else {
      this.logger.warn('üìß Email notifications disabled (missing EMAIL_* env vars)');
    }

    this.discordWebhookUrl = process.env.DISCORD_WEBHOOK_URL;
    if (this.discordWebhookUrl) {
      this.logger.log('üîî Discord notifications enabled');
    } else {
      this.logger.warn('üîî Discord notifications disabled (missing DISCORD_WEBHOOK_URL)');
    }
  }

  async notifyImageGeneration(payload: ImageNotificationPayload) {
    if (!this.notifyOnImageGeneration) {
      return;
    }

    const tasks: Promise<void>[] = [];

    if (this.emailTransporter && this.emailTo) {
      tasks.push(this.sendEmailNotification(payload));
    }

    if (this.discordWebhookUrl) {
      tasks.push(this.sendDiscordNotification(payload));
    }

    if (!tasks.length) {
      this.logger.debug('No notification channels configured; skipping image notification');
      return;
    }

    await Promise.allSettled(tasks);
  }

  private async sendEmailNotification(payload: ImageNotificationPayload) {
    if (!this.emailTransporter || !this.emailTo || !this.emailFrom) {
      return;
    }

    try {
      await this.emailTransporter.sendMail({
        from: this.emailFrom,
        to: this.emailTo,
        subject: `üñºÔ∏è Image generated by ${payload.userEmail}`,
        html: `
          <p><strong>User:</strong> ${payload.userEmail}</p>
          <p><strong>Prompt:</strong> ${payload.prompt}</p>
          <p><strong>Model:</strong> ${payload.model}</p>
          <p><strong>Provider:</strong> ${payload.provider}</p>
          <p><strong>Image URL:</strong> <a href="${payload.imageUrl}" target="_blank">${payload.imageUrl}</a></p>
        `,
      });
    } catch (error: any) {
      this.logger.error(`Failed to send email notification: ${error.message}`);
    }
  }

  private async sendDiscordNotification(payload: ImageNotificationPayload) {
    if (!this.discordWebhookUrl) {
      return;
    }

    try {
      await axios.post(this.discordWebhookUrl, {
        content: `üñºÔ∏è **${payload.userEmail}** generated an image`,
        embeds: [
          {
            title: 'Image Generation Details',
            fields: [
              { name: 'Prompt', value: payload.prompt.substring(0, 256) || 'N/A' },
              { name: 'Model', value: payload.model, inline: true },
              { name: 'Provider', value: payload.provider, inline: true },
            ],
            image: payload.imageUrl.startsWith('http') ? { url: payload.imageUrl } : undefined,
            timestamp: new Date().toISOString(),
          },
        ],
      });
    } catch (error: any) {
      this.logger.error(`Failed to send Discord notification: ${error.message}`);
    }
  }
}

